'''
Для работы скрипта, нужно определить переменные среды:
LISTENER=oralistener-test.local
SERVICE=test_db
USER=test
PASSWORD=test
'''

import oracledb
from datetime import datetime
import os

'''
1 - remote_addr
2 - remote_user \ - \
3 - time_local
4 - request (метод, URL, протокол)
5 - status
6 - body_bytes_sent
7 - referer
8 - user_agent
9 - http_x_forwarded_for'''

sLogFile = os.getenv('NGINXLOG')

class loader():
    def __init__(self, sFileName, prefix = 'nginx'):
        self.filename = sFileName
        self.prefix = prefix
        self.sHostName = os.getenv('LISTENER')
        self.sService = os.getenv('SERVICE')
        self.sUserName = os.getenv('USER')
        self.sUserPass = os.getenv('PASSWORD')


    def __checkaddr(self, sAddr):
        try:
            addr = sAddr.split('.')
            return ''.join([f"{str(int(r))}." for r in addr])[:-1]

        except ValueError:
            return None

    def __formatdate(self, sDate):
        try:
            return datetime.strptime(sDate, "%d/%b/%Y:%H:%M:%S")
        except ValueError:
            return None

    def __getstatus(self, lValues):
        try:
            return lValues[2].strip().split(' ')[0]
        except Exception as e:
            return None

    def __getbytes(self, lValues):
        try:
            return lValues[2].strip().split(' ')[1]
        except Exception as e:
            return None

    def __getrefer(self, lValues):
        try:
            return lValues[3]
        except Exception as e:
            return None

    def __getuseragent(self, lValues):
        try:
            return lValues[5]
        except Exception as e:
            return None

    def __getforwarded(self, lValues):
        try:
            return lValues[7]
        except Exception as e:
            return None

    def __getremoteuser(self, lValues):
        try:
            return ''.join([s for s in (lValues[2], lValues[3])])
        except Exception as e:
            return None

    def __connectOracle(self):
        return oracledb.connect(host=self.sHostName, port=1521, service_name=self.sService, user=self.sUserName, password=self.sUserPass)


    def ParseNginx(self):
        '''
        Превратим плоский файл в список словарей
        :return: [{}]
        '''
        dRequest = {}
        lLog = []
        try:
            file = self.filename
            lines = open(file, 'r')
            for line in lines:
                if line.startswith(self.prefix):
                    val = line.split('|')[1:]
                    #print(val)
                    sRemoteAddr = self.__checkaddr(val[0].strip().split(' ')[0])
                    #print(remote_addr)
                    if sRemoteAddr:
                        sRemoteUser = self.__getremoteuser(val[0].split(' '))
                        #[24/Feb/2026:00:53:34 +0000]
                        pos = val[0].find('[')
                        time_local = self.__formatdate(val[0][pos+1:pos+21])
                        #print(date)
                        pos = val[0].find(']')
                        info = val[0][pos+1:-1].strip()
                        if info.startswith('"POST') or info.startswith('"GET'):
                            separated = info.split('"')
                            sRequest = separated[1].split(' ')

                            if sRequest:
                                dRequest.update({'method':sRequest[0], 'url':sRequest[1], 'protocol':sRequest[2]})
                                #print(dRequest)
                            sStatus = self.__getstatus(separated)
                            sBytes = self.__getbytes(separated)
                            sRefer = self.__getrefer(separated)
                            sUser_agent = self.__getuseragent(separated)
                            sHttp_x_forwarded_for = self.__getforwarded(separated)
                            lLog.append({'remote_addr':sRemoteAddr,
                                         'remote_user':sRemoteUser,
                                         'time_local':time_local,
                                         'request':dRequest,
                                         'statuscode':sStatus,
                                         'body_bytes_sent':sBytes,
                                         'referer':sRefer,
                                         'user_agent':sUser_agent,
                                         'http_x_forwarded_for':sHttp_x_forwarded_for,})

            return  lLog



        except Exception as e:
            print(f'Exception {e}')
            return None

    def createTable(self):
        sSql = '''create table nginxlogs
                                        (
                                          id                   number GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                                          remote_addr          varchar2(255),
                                          remote_user          varchar2(255),
                                          time_local           timestamp,
                                          request_method       varchar2(255),
                                          request_url          varchar2(255),
                                          request_protocol     varchar2(255),
                                          statuscode           number,
                                          body_bytes_sent      number,
                                          referer              varchar2(255),
                                          user_agent           varchar2(255),
                                          http_x_forwarded_for varchar2(255)
                                        )
                                        tablespace users'''
        try:
            connection = self.__connectOracle()
            cursor = connection.cursor()
            cursor.execute(sSql)

        except Exception as e:
            print(f"не удалось создать таблицу {e}")

    def loadToDb(self, lLog):
        resulr = {'ERR':None, 'rows':0}
        data=[]
        rows = 0
        sSql = '''INSERT INTO nginxlogs (
                                        remote_addr,
                                        remote_user,
                                        time_local,
                                        request_method,
                                        request_url,
                                        request_protocol,
                                        statuscode,
                                        body_bytes_sent,
                                        referer,
                                        user_agent,
                                        http_x_forwarded_for
                                    ) VALUES (
                                        :remote_addr,
                                        :remote_user,
                                        :time_local,
                                        :request_method,
                                        :request_url,
                                        :request_protocol,
                                        :statuscode,
                                        :body_bytes_sent,
                                        :referer,
                                        :user_agent,
                                        :http_x_forwarded_for
                                    )'''
        try:
            connection = self.__connectOracle()
            cursor = connection.cursor()
            cursor.arraysize = 1000
            for line in lLog:
                statuscode = line.get('statuscode')
                body_bytes_sent = line.get('body_bytes_sent')

                data.append([line.get('remote_addr'),
                            line.get('remote_user'),
                            line.get('time_local'),
                            line.get('request').get('method'),
                            line.get('request').get('url'),
                            line.get('request').get('protocol'),
                            int(statuscode) if statuscode else None,
                            int(body_bytes_sent) if body_bytes_sent else None,
                            line.get('referer'),
                            line.get('user_agent'),
                            line.get('http_x_forwarded_for')])

            cursor.prepare(sSql)
            cursor.executemany(None, data)
            rows = cursor.rowcount
            cursor.execute('commit')
            resulr['rows'] = rows
            return resulr

        except Exception as e:
            resulr.update({'ERR':e})
            print(f'Exception {e}')
            return resulr
        finally:
            if cursor:
                cursor.close()

            if connection:
                connection.close()


'''
Укажем, где лежит лог
(берем из переменной окружения 'NGINXLOG')
'''
d = loader(sLogFile)
'''
создадим таблицу.
Если уже есть - то просто вернется исключение
'''
d.createTable()

'''
Распарсим лог.
В моем логе, почему то нет времени респонса
'''
log = d.ParseNginx()

'''
Запишем все в базу. А в базе, уже у нас есть все возможности SQL
--количество запросов с адреса
select remote_addr, count(1) from NGINXLOGS t group by remote_addr order by 2 desc
--количество запросов в минуту
select to_char(t.time_local,'dd.mm.rrrr hh24:mi'), count(1) from NGINXLOGS t group by to_char(t.time_local,'dd.mm.rrrr hh24:mi') order by 2 desc
--запросы с кодом ответа не 200
select t.statuscode, t.* from NGINXLOGS t where t.statuscode !=200 
select t.statuscode, t.remote_addr, count(1) from NGINXLOGS t where t.statuscode !=200 group by t.statuscode, t.remote_addr order by 3 desc
--На самом деле не знаю, почему, я сразу не подумал про загрузить все в базу и там уже делать с логом все, что угодно
'''
res = d.loadToDb(log)


if res:
    ERR = res.get('ERR', None)
    if not ERR:
        print(f'загружено {res.get("rows")}')
    else:
        print(f'произошла ошибка {ERR}')


